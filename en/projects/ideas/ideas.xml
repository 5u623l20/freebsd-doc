<?xml version="1.0" encoding="ISO-8859-1" ?>
<!DOCTYPE news PUBLIC "-//FreeBSD//DTD FreeBSD XML Database for
Ideas//EN"
"http://www.FreeBSD.org/XML/www/share/sgml/ideas.dtd">

<!-- Simple schema for FreeBSD Project feature request ideas.

     Top level element is <ideas>, which contains a collection of
     <category>s.  Each category contains a <title> element, and a
     collection of <idea> elements.

     Each <idea> contains a <title>, <desc>, and <requirements>.
-->

<ideas>
  <cvs:keywords xmlns:cvs="http://www.FreeBSD.org/XML/CVS" version="1.0">
    <cvs:keyword name="freebsd">
      $FreeBSD: www/en/projects/ideas/ideas.xml,v 1.15 2007/03/18 02:28:50 murray Exp $
    </cvs:keyword>
  </cvs:keywords>

  <category>
    <title>File System</title>

    <idea id="msdosfs" class="soc">
      <title>FAT (msdosfs) infrastructure work</title>

      <desc>
<p><strong>Technical Contact</strong>: <a
  href="mailto:rwatson@FreeBSD.org">Robert Watson</a></p>
<p>The FreeBSD FAT implementation, msdosfs, offers scope for a number of
  projects:</p>
<ul>
  <li>General cleanup.</li>
  <li>Introduce appropriate locking to make the file system operate without
    the Giant lock (MPSAFE).</li>
  <li>Make msdosfs robust in the presence of unexpected disk removal, since
    it is frequently used with removable devices.</li>
</ul>
<p>It is unclear to what extent the last of these items, arguably the most
  useful, will require modifying surrounding infrastructure such as BIO,
  GEOM, and VM.</p>
<p><strong>Requirements</strong>:</p>
<ul>
  <li>Strong C programming skills.</li>
  <li>Familiarity with concurrent programming techniques.</li>
  <li>Familiarity with FAT file system layout.</li>
  <li>Familiarity with virtual file system and virtual memory.</li>
</ul>
      </desc>
    </idea>

    <idea id="extenddump" class="soc">
      <title>Improve the performance of dump/restore</title>

      <desc><p>A performance evaluation of the split cache (as is) and an unified cache
  (like e.g. NetBSD) would be interesting.  More details in <a
    href="http://lists.freebsd.org/pipermail/freebsd-hackers/2007-February/019666.html">
  this</a> mail to the hackers mailing list.  Additional improvements are
  welcome too.</p>
<p><strong>Requirements</strong>:</p>
<ul>
  <li>Knowledge of C programming.</li>
  <li>Basic understanding of backup/restore procedures.</li>
</ul></desc>

    </idea>

    <idea id="mdfs">
      <title>MDFS lockups</title>

      <desc><p>Fix MDFS lockups when using async operation modes.  <a
  href="&cgibase;/cvsweb.cgi/sys/dev/md/md.c#rev1.115">Revision 1.115 of
  md.c</a> has a discussion of the problem.</p>
<p><strong>Requirements</strong>:</p>
<ul>
  <li>Ability to read and understand foreign C code.</li>
  <li>Ability to write C code.</li>
  <li>Knowledge of the VFS and VMA subsystems.</li>
</ul>
      </desc>
    </idea>

    <idea id="tmpfs">
      <title>TMPFS</title>

      <desc>
<p><strong>Technical contact</strong>: <a
  href="mailto:netchild@FreeBSD.org">Alexander Leidinger</a></p>
<p>At the moment FreeBSD includes a memory-based file system called mfs.
  mfs is just an implementation of the regular ffs - designed for
  persistent storage - on top of the (volatile) virtual memory system.
  This means that it uses the same data structures as the on-disk
  implementation, rendering less than optimal performance and memory
  usage.  With tmpfs,  FreeBSD would gain a memory file system which uses
  less memory and is faster.</p>
<p><strong>Goals</strong>:</p>
<ul>
  <li>Port the tmpfs file system.</li>
  <li>Adopt the documentation (including the file system how-to)</li>
</ul>
<p><a href="mailto:rohitj@purpe.com">Rohit Jalan</a> has begun <a
  href="http://lists.freebsd.org/pipermail/freebsd-hackers/2006-February/015575.html">porting</a>
  the NetBSD tmpfs to FreeBSD. The source and some benchmarks can be found
  <a href="http://download.purpe.com/tmpfs">here</a>. Before it can enter the
  tree locking has to be added. There are also <a
  href="http://www.Leidinger.net/FreeBSD/tmpfs_bugs.mails">some bugs</a> to take
  care of. Rohit has no time to work on it in the next months, any volunteer is
  welcome to continue his work.</p>
<p><strong>Requirements</strong>:</p>
<ul>
  <li>Ability to read and understand foreign C code.</li>
  <li>Ability to write C code.</li>
  <li>A little bit of knowledge of the VFS subsystem.</li>
</ul>
      </desc>
    </idea>

  </category>

  <category>
    <title>Kernel</title>

    <idea id="autoreport" class="soc">
      <title>Automated kernel crash reporting system</title>

      <desc>
<p><strong>Technical contact</strong>: <a href="mailto:delphij@FreeBSD.org">Xin LI</a>, <a
  href="mailto:howard0su@gmail.com">Howard SU</a></p>

<p>In some recent operating systems, it is common that crashes are
  automatically reported to its vendor, which is very helpful for
  finding hidden problems that can not be easily triggered by usual
  test cases.  Newer GNOME applications also has similar functionalities.</p>

<p>This project would consist two parts.  One is some improvements over
  the current savecore rc.d script to teach it how to collect necessary
  information (of course, automatic reporting has to be explicitly enabled
  by individual system administrators, and should have at least three
  options: not to send out anything at all as a default, send out after
  administrator confirmation, and automatically send all necessary information)</p>

<p>Another part is the server side one, which will keep a database of backtraces
  where similar (call stack minus addresses) reports are kept together and be
  considered as a "vote", to make it possible for developers and release engineers
  to focus on the most commonly triggered issues.</p>

<p><strong>Requirements</strong>:</p>
<ul>
  <li>Strong knowledge of C.</li>
  <li>Understanding of kernel debugging.</li>
  <li>Knowledge about web application as well as database.</li>
  <li>Understanding of user privacy protection.</li>
</ul>
      </desc>
    </idea>

    <idea id="setproctitle" class="soc">
      <title>Avoiding syscall overhead</title>

      <desc>
<p><strong>Technical contact</strong>: <a href="mailto:kris@FreeBSD.org">Kris Kennaway</a></p>

<p>setproctitle() calls are a serious
  performance bottleneck in a default pgsql configuration (they are
  called at least once per query, which might be thousands of times per
  second - I measured a performance impact of about 33% on sysbench).</p>

<p>One idea for avoiding the syscall (and global sysctl lock) overhead
  for this kind of thing would be a memory page shared between kernel
  and userland which libc could read/write to access things like the
  process title.  There are potentially many other data values that
  could be optimized by a similar method.  This is presumably a well
  established technique in other OSes.</p>

<p>This project requires mentoring/review/planning with someone with
  significant VM experience to make sure this approach
  works properly.  Done incorrectly, this could result in fairly
  massive security holes, performance issues (perhaps not visible in
  simple benchmarks), etc.</p>

<p><strong>Requirements</strong>:</p>
<ul>
  <li>Strong knowledge of C.</li>
  <li>Understanding of kernel VM.</li>
</ul>
      </desc>
    </idea>

      <idea id="cpuusage">
        <title>CPU usage display in top</title>

        <desc>
<p>The current kernel statistics do not know how to calculate the CPU usage
  of threaded processes.  A volunteer has to understand the current statistics
  model, design a new statistics model and implement it.  This problem only
  occurs with M:N threading on libpthread.</p>
<p><strong>Requirements</strong>:</p>
<ul>
  <li>Ability to read and understand foreign C code.</li>
  <li>Ability to write C code.</li>
  <li>A good understanding of the FreeBSD SMP system.</li>
</ul>
        </desc>
      </idea>

      <idea id="docsysctl">
        <title>Document all sysctls</title>
        <desc>
<p><strong>Technical contacts</strong>: <a
  href="mailto:mat@FreeBSD.org">Mathieu Arnold</a>, <a
  href="mailto:brd@FreeBSD.org">Brad Davis</a></p>
<p>The sysctl(8) utility retrieves kernel states and allows processes with
  appropriate privilege to change kernel states.  On request it is able to
  display description lines which document the kernel state.  Unfortunately
  not every sysctl is documented.  This task is possible to share with other
  volunteers.  mat has done some development in Perforce, in the
  mat_sysctl_cleanup branch.</p>
<ul>
  <li>Find every undocumented sysctl in the kernel.</li>
  <li>Try to determine what this sysctl is for and document it.</li>
</ul>
<p><strong>Requirements</strong>:</p>
<ul>
  <li>Ability to read and understand foreign C code.</li>
</ul>
        </desc>
      </idea>

      <idea id="docsound">
	<title>Document the sound subsystem</title>

	<desc>
<p><strong>Technical contacts</strong>: <a
  href="mailto:netchild@FreeBSD.org">Alexander Leidinger</a>, <a
  href="mailto:ariff@FreeBSD.org">Ariff Abdullah</a></p>
<ul>
  <li>Add sound subsystem related section 9 manual pages, so far no sound
    subsystem related manual pages exists.</li>
  <li>Add an example driver in share/examples which allows to write a new
    driver. For this purpose the example driver should contain enough
    documentation as comments and/or pointers to documentation in man-section
    9. This work can be based upon <a
    href="http://people.FreeBSD.org/~cg/template.c">this template.</a></li>
  <li>Rewrite the sound subsystem chapter in the FreeBSD Architecture Handbook.
    The rewrite should contain an overview of the available parts in the sound
    subsystem and how they interact (data flow, dependencies, ...) and fit
    together. Additionally it should contain links to already available
    documentation (official standards, section 9 manual pages, ...).</li>
  <li>A <a href="http://wiki.freebsd.org/soundsystem">wiki page</a>
    documenting everything related to the sound subsystem in FreeBSD has been
    created.</li>
</ul>
<p><strong>Requirements</strong>:</p>
<ul>
  <li>Ability to read and understand foreign C code.</li>
  <li>Documentation writing skills.</li>
</ul>

        </desc>
      </idea>

      <idea id="dtrace">
	<title>DTrace</title>

	<desc>
<p><strong>Technical contact</strong>: <a
  href="mailto:jb@FreeBSD.org">John Birrell</a></p>
<p><strong>URL</strong>: <a
  href="http://perforce.freebsd.org/depotTreeBrowser.cgi?FSPC=//depot/projects/dtrace">Perforce
  repository</a>, <a
  href="http://people.freebsd.org/~jb/dtrace/index.html">DTrace for
  FreeBSD</a></p>
<p>DTrace is a dynamic tracing facility designed by Sun Microsystems and
  released in Solaris 10.  They have since released the major part of
  Solaris under the banner of OpenSolaris and the Common Development and
  Distribution License (CDDL) 1.0.  John Birrell has created an initial port and
  should be contacted for information on what tasks remain to be done.</p>
<p><strong>Requirements</strong>:</p>
<ul>
  <li>Ability to read and understand foreign C code.</li>
  <li>Ability to write C code.</li>
  <li>A good understanding of the FreeBSD kernel.</li>
</ul>
	</desc>
      </idea>

      <idea id="assembler">
	<title>DWARF2 call frame information</title>

	<desc>
<p>A debug kernel is not able to show stack traces with cross exceptions
  anymore.  This is because we do not emit any dwarf2 call frame information
  for any assembler code, since gdb switched to the dwarf2 format.  A volunteer
  should annotate every assembler file [*.[sS]] with dwarf2 call frame
  information.</p>
<p><strong>Requirements</strong>:</p>
<ul>
  <li>Knowledge of assembly code.</li>
  <li>Knowledge of ".cfi_*" pseudo-ops to insert dwarf2 frame descriptors.</li>
</ul>
	</desc>
      </idea>

      <idea id="modrefcnt">
	<title>Dynamic module references</title>

	<desc>
<p><strong>Technical contact</strong>: <a
  href="mailto:sam@FreeBSD.org">Sam Leffler</a></p>
<p>Kernel modules may have dynamic references created during operation.
  For example net80211 key entries reference functions in the crypto module
  that implements the key's cipher.  Presently there is no standard mechanism
  for expressing this dependency so that module unloading is disallowed;
  instead modules must track references and implement their own semantics.
  This task is to define and implement a general mechanism for tracking
  these references and use them in handling module unload requests.</p>
<p><strong>Requirements</strong>:</p>
<ul>
  <li>Good knowledge of C.</li>
  <li>Kernel awareness.</li>
</ul>
	</desc>
      </idea>
    <idea id="kernel-linuxemu" class="soc">
      <title>Extending the in-kernel linux emulation layer</title>

      <desc>
<p><strong>Technical contact</strong>: <a href="mailto:luigi@FreeBSD.org">Luigi Rizzo</a></p>

<p>Recently, a project was started to let linux device drivers
  compile on FreeBSD through an in-kernel emulation layer, which
  implements part of the linux kernel API on top of the FreeBSD
  kernel API.  The initial implementation was good enough to
  support a few USB webcam drivers, and is documented 
  <a
href="http://info.iet.unipi.it/~luigi/FreeBSD/linux_bsd_kld.html">here</a>.</p>

<p>The goal of this project is to extend the emulation layer
  to cover more of the linux kernel API. Two areas that need
  further work are the API used by network device drivers (e.g.
  many USB wired and wireless device drivers), and the API used
  by memory-mapped devices and drivers (e.g. analog or DVB video
  acquisition cards, both USB and PCI).</p>

<p>A Summer of Code applicant would be required to choose a significant set of
  extensions to the existing work (e.g. one of those indicated
  above), and select at least two linux device drivers to be
  ported to FreeBSD using the newly implemented functions.</p>

<p>Before the start of the project a Summer of Code applicant is expected to
  have studied the above URL and understood the emulation technique
  used, and to have/acquire access to at least some of the hardware
  involved, so that actual functionality tests can be performed
  in addition to the compile tests.</p>
      </desc>
    </idea>

      <idea id="ktrace">
	<title>Extend ktrace/kdump output</title>

	<desc>
<p><strong>Technical contact</strong>: <a
  href="mailto:netchild@FreeBSD.org">Alexander Leidinger</a></p>
<p>The ktrace(1) facility allows to monitor what running processes do.  It
  allows to determine if a process is stuck or if it still does useful work.
  The goal of this item is to look at the kernel interfaces, add missing
  "pieces" (e.g. syscall's) to the ktrace output and to extend the output
  with "decoded" (translating hex/dec values into human readable
  information, e.g. O_RDONLY in the case of open(2)) information.  Some work
  has been completed and committed, but a few parts still remains.  More
  information is available <a
  href="http://lists.freebsd.org/pipermail/freebsd-arch/2006-April/005107.html">here</a>.</p>
<p>Also, a related project would be to modify ktrace to write to pipes.
  Currently the ktrace infrastructure requires the dump output go to a file.
  It would be useful to be able to instead have it write to pipe, or in fact
  any type of file descriptor.</p>
<p><strong>Requirements</strong>:</p>
<ul>
  <li>Knowledge of C.</li>
  <li>Good knowledge of POSIX interfaces or how to use man(1).</li>
  <li>No fear to look into the kernel sources.</li>
</ul>
	</desc>
      </idea>

      <idea id="fastcall">
	<title>Fast syscall support for FreeBSD/i386</title>

	<desc>
<p><strong>Technical contact</strong>: <a
  href="mailto:rookie@gufi.org">Attilio Rao</a></p>
<p>The instruction pair sysenter and sysexit can contribute to certain
  performance improvements when a syscall is made on IA32.  There is however
  no implementation of this available for FreeBSD, so a volunteer
  would have to add sysenter/sysexit support to the kernel.  This
  needs to be properly evaluated and benchmarked though, so a complete
  implementation should therefore also contain informative benchmarks which
  shows a clear improvement in performance.  It is also important to stress
  the fact that this project is of research quality and measures should be
  taken to ensure that no regressions are introduced.  Another interesting
  extension to this project would be to investigate and evaluate the
  possibility to use mmx/xmm registers to gather syscalls arguments.
  <a href="mailto:davidxu@FreeBSD.org">David Xu</a> has some <a
  href="http://lists.freebsd.org/pipermail/freebsd-current/2006-July/064403.html">work
  in progress</a> in his <a
  href="http://perforce.freebsd.org/depotTreeBrowser.cgi?FSPC=//depot/user/davidxu/sysenter">sysenter</a>
  branch in the perforce repository.</p>
<p><strong>Requirements</strong>:</p>
<ul>
  <li>Ability to read and understand foreign C code.</li>
  <li>Ability to write C code.</li>
  <li>Ability to write and understand x86 assembly.</li>
</ul>
	</desc>
      </idea>

      <idea id="geninput">
	<title>Generic input device layer</title>

	<desc>
<p><strong>Technical contact</strong>: <a
  href="mailto:philip@FreeBSD.org">Philip Paeps</a></p>
<p>The kernel is lacking a generic input device layer analogous to the Linux
  'input core' layer.  Having such a layer would make it easy to write e.g.
  touchscreen support (Philip Paeps has some work-in-progress regarding pointer
  devices and touchscreen support, but not enough time to also cover keyboard
  support or other generic features).</p>
<p><strong>Requirements</strong>:</p>
<ul>
  <li>Ability to read and understand foreign C code.</li>
  <li>Ability to write C code.</li>
</ul>
	</desc>
      </idea>

      <idea id="powerd">
	<title>Implement and profile algorithms for powerd</title>
	<desc>
<p><strong>Technical contacts</strong>: <a
  href="mailto:njl@FreeBSD.org">Nate Lawson</a>, <a
  href="mailto:bruno@FreeBSD.org">Bruno Ducrot</a></p>
<p>Implement a range of predictive algorithms (and perhaps design your own)
  and profile them for power usage and performance loss. The best
  algorithm will save the most power while losing the least performance.  This
  has been discussed on the <a href="mailto:acpi@FreeBSD.org">ACPI</a> mailing
  list and Bruno Ducrot has some early patches.</p>
<p><strong>Requirements</strong>:</p>
<ul>
  <li>Basic C knowledge.</li>
  <li>Laptop supported by cpufreq(4).</li>
</ul>
	</desc>
      </idea>


    <idea id="usb-update" class="soc">
      <title>Improving the USB stack in FreeBSD</title>

      <desc>
<p><strong>Technical contact</strong>: <a href="mailto:luigi@FreeBSD.org">Luigi Rizzo</a></p>

  <p>The USB stack in FreeBSD suffers from a few problems, including
    lack of functionality (e.g. isochronous support for USB2 devices),
    lack of documentation (most of the code is undocumented and
    derives from other BSD implementations), lack of support (there
    is not, to our knowledge, active development of the stack),
    and the fact that it is still running under the Giant lock.</p>

  <p>There is an alternate USB stack under development but it also
    suffers from its own share of problems: while it supports
    isochronous transfers for USB2 and does not run under Giant, it is
    also almost completely undocumented, and it exports a different API
    from the current one, which in turn causes portability problems for
    device drivers that run on top of USB. Additionally, it is not in
    widespread use.</p>

  <p>The goal of this project is to improve the FreeBSD stack in one
    of the following ways:</p>

  <ul>
    <li>Add documentation and isochronous USB2 transfers to the existing
      driver. Documentation also includes a detailed description of the
      locking requirements to ease the move to a different locking
      architecture;</li>
    <li>Add documentation and a compatibility layer to the 'new' usb
      stack, and verify that the basic functionality is preserved for
      widely used drivers (umass, mouse, keyboard, etc.).
      This work will likely require some debugging of the new code
      which we expect to be less tested than the existing one, and so
      more prone to undetected bugs.</li>
  </ul>

  <p>The production of suitable documentation in the source is a key
   requirement of the project.</p>
      </desc>
    </idea>

      <idea id="iscsi">
	<title>iSCSI</title>

	<desc>
<p><strong>Technical contact</strong>: <a
  href="mailto:danny@cs.huji.ac.il">Danny Braniss</a></p>
<p>Danny Braniss has been working on an iSCSI stack for FreeBSD for some time
  now.  His work is in Perforce, and he has posted several patch sets
  and had numerous discussions on the mailing lists.</p>
<p><strong>Requirements</strong>:</p>
<ul>
  <li>Ability to read and understand foreign C code.</li>
  <li>Ability to write C code.</li>
  <li>Knowledge about (i)SCSI/CAM.</li>
</ul>
	</desc>
      </idea>

    <idea id="firewire-locking" class="soc">
      <title>Locking the FireWire device driver</title>

      <desc><p><strong>Technical contact</strong>: <a href="mailto:simokawa@FreeBSD.ORG">Hidetoshi Shimokawa</a></p>

<p>The IEEE1394 (a.k.a. FireWire) device driver in FreeBSD is
still under the Giant lock. The FireWire driver consists of
several parts (fwohci, firewire, sbp, fwe and fwip) and
they all need to be locked.</p>

<p><strong>Goals</strong>:</p>
<ul>
  <li>Protect the driver by SMP locks and remove the Giant lock
     from the driver.</li>
</ul>

<p><strong>Requirements</strong>:</p>
<ul>
  <li>Knowledge of kernel programming.</li>
  <li>Knowledge of device drivers.</li>
  <li>Knowledge of SMP locking.</li>
</ul>

      </desc>
    </idea>

      <idea id="busalloc" class="soc">
	<title>New bus_alloc_resources() API</title>

	<desc>
<p><strong>Technical contact</strong>: <a
  href="mailto:imp@FreeBSD.org">Warner Losh</a></p>
<p>Recently, bus_alloc_resources has been added to the kernel.  This,
  coupled with the bus_space_{read,write} family of functions can
  significantly reduce the setup needed for driver resource allocation.
  Unfortunately, most of the drivers in the tree have not yet been
  converted, thus ensuring that the old, bad way continues.  What is needed
  is for someone to go through the drivers in the tree and convert them.
  After conversion, they need to ensure that they still work on at least some
  hardware and work with someone to get them committed.  <a
  href="mailto:imp@FreeBSD.org">Warner Losh</a> is available for review and
  coordination of committing.</p>
<p><strong>Requirements</strong>:</p>
<ul>
  <li>Ability to read, write and understand C code.</li>
  <li>Knowledge about device drivers.</li>
  <li>Access to hardware to test on.</li>
</ul>
	</desc>
      </idea>

      <idea id="pcihotplug">
	<title>PCI-Hotplug support</title>

	<desc>
<p><strong>Technical contact</strong>: <a
  href="mailto:bms@FreeBSD.org">Bruce M. Simpson</a></p>
<p><!-- Description needed --></p>
<p><strong>Requirements</strong>:</p>
<ul>
  <li>Ability to read and understand foreign C code.</li>
  <li>Ability to write C code.</li>
  <li>A good understanding of low-level access of the hardware.</li>
  <li>A good understanding of FreeBSD device drivers.</li>
</ul>
	</desc>
      </idea>

      <idea id="psched">
	<title>Pluggable Disk Scheduler</title>

	<desc>
<p><strong>Technical contact</strong>: <a
  href="mailto:s223560@studenti.ing.unipi.it">Emiliano Mennucci</a></p>
<p><strong>References</strong>: <a
  href="http://wiki.freebsd.org/moin.cgi/Hybrid">The Pluggable Disk
  Schedulers SoC project</a>, <a
  href="http://www.happyemi.org/hybrid/">Patches</a></p>
<p>Our "Pluggable Disk Schedulers" SoC 2005 project resulted in code which
  solved the problem where large sequential I/O requests, or certain
  access patterns from one or a few processes, might almost completely
  starve other processes.  It is available as a patch for RELENG_4 and
  RELENG_5.  Unfortunately the code in FreeBSD-current (and RELENG_6)
  changed too much, so that the patches can not be committed.  The goal
  of this project is to port the pluggable disk schedulers to the GEOM
  framework.</p>
<p><strong>Requirements</strong>:</p>
<ul>
  <li>Ability to read and understand foreign C code.</li>
  <li>Ability to write C code.</li>
  <li>Knowledge of GEOM (or interest in getting familiar with it).</li>
</ul>
	</desc>
      </idea>

      <idea id="sensors">
	<title>Port OpenBSD's sensors framework</title>

	<desc>
<p><strong>References</strong>: <a
  href="http://www.openbsd.org/papers/bsdcan06-biosensors.pdf">Overview</a>,
  <a href="http://www.openbsd.org/cgi-bin/cvsweb/src/usr.sbin/sensorsd/">
  http://www.openbsd.org/cgi-bin/cvsweb/src/usr.sbin/sensorsd/</a>,
  <a href="http://www.openbsd.org/cgi-bin/cvsweb/src/sbin/bioctl/">
  http://www.openbsd.org/cgi-bin/cvsweb/src/sbin/bioctl/</a>, <a
  href="http://www.openbsd.org/cgi-bin/cvsweb/src/sys/scsi/safte.c">
  http://www.openbsd.org/cgi-bin/cvsweb/src/sys/scsi/safte.c</a></p>
<p>The OpenBSD sensors framework is an unified way of handling
  any kind of hardware sensor one can image.  A sensor driver collects
  data from system sensors, SAS devices, harddisks, ... and allows an
  administrator to query the data with the unified management interface.</p>
<p><strong>Requirements</strong>:</p>
<ul>
  <li>Ability to read and understand foreign C code.</li>
  <li>Ability to write C code.</li>
</ul>
	</desc>
      </idea>

      <idea id="trussprocfs">
	<title>Remove procfs dependencies</title>

	<desc>
<p><strong>Technical contact</strong>: <a
  href="mailto:mux@FreeBSD.org">Maxime Henrion</a></p>
<p>Someone needs to finish the support for PT_SYSCALL in the ptrace()
  subsystem, and add support for another ptrace() command that will replace
  the PIOCWAIT and PIOCSTATUS ioctls of procfs (should probably be named
  PT_WAIT), in order for truss(1) to be able to work without procfs(5).
  Removing the procfs(5) dependency from ps -e is also desirable.</p>
<p><strong>Requirements</strong>:</p>
<ul>
  <li>C knowledge.</li>
  <li>Understanding of kernel debugging interfaces.</li>
</ul>
	</desc>
      </idea>

      <idea id="syncer">
	<title>Rewrite the in-kernel file system syncer</title>

	<desc>
<p><strong>References</strong>: <a
  href="http://lists.freebsd.org/mailman/htdig/freebsd-arch/2005-March/003594.html">mail
  #1</a>, <a
  href="http://lists.freebsd.org/mailman/htdig/freebsd-performance/2005-February/001083.html">mail
  #2</a></p>
<p><strong>Goals</strong>:</p>
<ul>
  <li>Change the syncer so it can sync out to multiple physical devices
    simultaneously.</li>
  <li>Only write out up to X megabytes of data, remember where it
    left off, and then proceed to the next dirty file (OpenBSD and
    NetBSD already do this).</li>
  <li>Replace the write_behind code with something (detect the existence
    of a large amount of sequential dirty data and kick another thread
    to flush it out synchronously, instead of doing it itself
    asynchronously) integrated into the syncer (the data set size could
    perhaps be increased from 64KB to 1MB).</li>
</ul>
<p><strong>Requirements</strong>:</p>
<ul>
  <li>Ability to read and understand foreign C code.</li>
  <li>Ability to write C code.</li>
  <li>Some understanding of the VM system / buffer cache.</li>
</ul>
	</desc>
      </idea>

      <idea id="suspend">
	<title>Suspend to disk</title>

	<desc>
<p><strong>Technical contacts</strong>: <a
  href="mailto:njl@FreeBSD.org">Nate Lawson</a>, <a
  href="mailto:bruno@FreeBSD.org">Bruno Ducrot</a></p>
<p>Implement a suspend/resume from disk mechanism.  Possibly use the dump
  functions to dump pages to disk, then use ACPI to put the system in S4 or
  power-off.  Resume would require changes to the loader to load the memory
  image directly and then begin executing again.</p>
<p><strong>Requirements</strong>:</p>
<ul>
  <li>Good knowledge of C.</li>
  <li>Understanding of the hardware/software interface.</li>
  <li>A laptop that works with ACPI.</li>
  <li>Kernel awareness.</li>
</ul>
	</desc>
      </idea>

      <idea id="bootcode">
	<title>Sync FreeBSD i386 boot code with DragonFly</title>

	<desc>
<p><strong>Technical contact</strong>: <a
  href="mailto:jhb@FreeBSD.org">John Baldwin</a></p>
<p>DragonFly invested a lot of time to clean up and document it.  Additionally
  they fixed some bugs.  Interesting files in the DragonFly CVS are
  sys/boot/i386/bootasm.h, sys/boot/i386/bootasmdef.c, sys/boot/boot0/*,
  sys/boot/boot2/*, sys/boot/i386/btx/*, sys/boot/i386/cdboot/*,
  sys/boot/i386/libi386/amd64_tramp.S, sys/boot/i386/libi386/biosdisk.c and
  sys/boot/i386/loader/main.c.  An interested volunteer has to compare and
  evaluate both implementations and port interesting/good parts.</p>
<p><strong>Requirements</strong>:</p>
<ul>
  <li>Ability to read and understand foreign C code.</li>
  <li>Ability to write C code.</li>
  <li>Knowledge of i386 assembly.</li>
  <li>Knowledge of BIOS interfaces.</li>
  <li>Knowledge of low-level boot behavior.</li>
</ul>
	</desc>
      </idea>

      <idea id="sysmod">
	<title>Syscons modularization</title>

	<desc>
<p>Separate the syscons code into distinct parts for input, output,
  console handling (switching, screen savers etc.) and terminal
  emulation.  Introduce fine-grained locking.  Also implement vt100 and
  vt220 emulation to supplement the existing SCO emulation.  Add a
  gettytab(5) capability for specifying the terminal emulation, and add
  entries to /etc/gettytab for the alternative emulations.</p>
<p>Optionally implement xterm emulation.  The top line of the screen
  should serve as a title bar, displaying the title set with the \e]0;
  escape sequence as well as the vty number.</p>
<p><strong>Requirements</strong>:</p>
<ul>
  <li>Ability to read and understand foreign C code.</li>
  <li>Ability to write C code.</li>
  <li>A good understanding of text terminals and terminal emulation.</li>
</ul>
	</desc>
      </idea>

    <idea id="sysenter" class="soc">
      <title>Sysenter for x86 syscalls.</title>

      <desc>
<p><strong>Technical contact</strong>: <a href="mailto:jeff@FreeBSD.org">Jeff Robertson</a></p>

<p>Sysenter is an optional feature on x86 processors that significantly reduces
the cost of calling system calls.  Implementing support for this feature would
require run-time selection of syscall code, most likely using a page which is
always mapped into each process that contains the system call code.  This would
also require some minor infrastructure in the kernel to provide the correct
entry points and stacks for kernel entry.  If there is enough time remaining
other features could be added to this global shared page to improve performance
of other syscalls.</p>

<p><strong>Requirements</strong>:</p>
<ul>
  <li>Solid grasp of assembly and machine state issues.</li>
  <li>Some familiarity with the FreeBSD VM.</li>
</ul>
      </desc>
    </idea>
  </category>

  <category>
    <title>Networking</title>

      <idea id="csup">
	<title>csup improvements</title>

	<desc>
<p><strong>Technical contact</strong>: <a
  href="mailto:mux@FreeBSD.org">Maxime Henrion</a></p>
<p><strong>URL's</strong>: <a
  href="http://mu.org/~mux/csup.html">csup homepage</a>, <a
  href="http://www.freebsd.org/cgi/cvsweb.cgi/projects/csup/">CVSweb</a>
  </p>
<p>Maxime Henrion is working on a rewrite of CVSup in C, called csup, and he has
  imported csup into the FreeBSD base system.  It should be ready for use in a
  stable environment, but there are however still several missing features.
  The following list should be a good starting point:</p>
<ul>
  <li>Add support for authentication.</li>
  <li>Add support for shell commands sent by the server.</li>
  <li>Add missing support for various CVSup options: -D, -a (requires
    authentication support), -e and -E (requires shell commands support)
    and the destDir parameter.</li>
  <li>Add support for CVS mode.  This is important for developers, since this
    mode sends the actual RCS files themselves.  This is very useful
    for storing a full copy of the CVS repository on the client machine.</li>
</ul>
<p><strong>Requirements</strong>:</p>
<ul>
  <li>Strong knowledge of C.</li>
  <li>Good knowledge of POSIX standards.</li>
  <li>Ability to work with multi-threaded applications.</li>
</ul>

	</desc>
      </idea>

      <idea class="soc" id="httppxe">
	<title>HTTP support for pxeboot</title>

	<desc>
<p><strong>Technical contact</strong>: <a
  href="mailto:rwatson@FreeBSD.org">Robert Watson</a></p>
<p>Implementing HTTP support for pxeboot would allow us to boot a machine using
  PXE and pull down a kernel from a web server rather than NFS.  This will
  allow us to install from DHCPD + Apache or even just DHCPD + a remote web
  server.  As PXE does not provide an integrated TCP stack, at least a
  minimal TCP implementation would need to be present in the FreeBSD PXE
  loader.</p>
<p><strong>Requirements</strong>:</p>
<ul>
  <li>Good PXE knowledge.</li>
  <li>Detailed knowledge of TCP/IP.</li>
</ul>
	</desc>
      </idea>

      <idea id="nfslockdsemantics">
	<title>NFS Lockd (improve semantics)</title>

	<desc>
<p><strong>Technical contact</strong>: <a
  href="mailto:alfred@FreeBSD.org">Alfred Perlstein</a></p>
<ul>
  <li>Improve the semantics of the NFS lockd in FreeBSD.  Apple has made
    certain enhancements that can be leveraged in our code base.</li>
  <li>Implement state recovery in the lockd.</li>
</ul>
<p><strong>Requirements</strong>:</p>
<ul>
  <li>Good knowledge of C.</li>
</ul>
	</desc>
      </idea>

      <idea id="nfslockdkernel">
	<title>NFS Lockd (kernel implementation)</title>

	<desc>
<p><strong>Technical contact</strong>: <a
  href="mailto:alfred@FreeBSD.org">Alfred Perlstein</a></p>
<p>Moving the lockd implementation into the kernel provides several key
  performance and semantic improvements.</p>
<p><strong>Requirements</strong>:</p>
<ul>
  <li>Good knowledge of C.</li>
  <li>Good understanding of NFS.</li>
  <li>Good understanding of locking.</li>
  <li>Good understanding of RPC.</li>
  <li>Good understanding of kernel level networking.</li>
</ul>
	</desc>
      </idea>

      <idea id="pfnetgraph" class="soc">
	<title>pf and netgraph interaction</title>

	<desc>
<p><strong>Technical contact</strong>: <a
  href="mailto:mlaier@FreeBSD.org">Max Laier</a></p>
<p>Teach pf to talk to the netgraph subsystem.  Requires a design on how to
  express this in pf.conf and implementation.  Being able to use divert
  sockets would be interesting as well and should be largely parallel with
  regards to the design.</p>
<p><strong>Requirements</strong>:</p>
<ul>
  <li>Good knowledge of C.</li>
  <li>Good understanding of kernel level networking.</li>
  <li>Basic understanding of pf and netgraph as a user at least.</li>
</ul>
	</desc>
      </idea>

      <idea class="soc" id="suptundaemon">
	<title>Super tunnel daemon</title>

	<desc>
<p><strong>Technical contact</strong>: <a
  href="mailto:phk@FreeBSD.org">Poul-Henning Kamp</a></p>
<p>IP can be tunneled over IP, UDP, TCP, SSH, DNS, HTTP and many other
  protocols, and this means that it is often possible to get a
  connection out through a firewall, but each of these encapsulations
  require prior setup of a specific program for each encapsulation, and
  the user must experiment to decide which one to use at any one time.
  The super tunnel daemon should implement pluggable encapsulations and
  make it automatically select the most efficient encapsulation that
  works at any one time. The user should not notice transitions from one
  encapsulation to another, apart from maybe a small delay.</p>
<p>Wanted features (not sorted or prioritized):</p>
<ul>
  <li>Autodetection of the environment (DHCP, DNS, routing, ...) in a
    non-offensive way (no global portscans allowed; asking via DHCP,
    zeroconf or similar technologies is ok) as far as possible.</li>
  <li>Plugin architecture for easy addition of further encapsulations.</li>
  <li>Failover from one encapsulation to another.</li>
  <li>Distinct configuration files for encapsulations which need to be
    configured (e.g. proxy, authentication, ...).</li>
  <li>Possibility to disable installed encapsulations.</li>
  <li>Print/log hints for protocols which require some configuration,
    e.g. telling the user to use keys and perhaps the ssh-agent for ssh.</li>
  <li>Configurable additional plugin directories (for plugins installed
    via the ports collection).</li>
  <li>Log how it is able to tunnel the traffic (this also makes it useful
    for finding unwanted holes in the configuration of a firewall).</li>
</ul>
<p><strong>Requirements</strong>:</p>
<ul>
  <li>Good knowledge of C.</li>
  <li>Good knowledge about networks.</li>
</ul>
	</desc>
      </idea>

      <idea class="soc" id="tcpipreg">
	<title>TCP/IP regression test suite</title>

	<desc>
<p><strong>Technical contact</strong>: <a
  href="mailto:rwatson@FreeBSD.org">Robert Watson</a>, <a
  href="mailto:gnn@FreeBSD.org">George V. Neville-Neil</a></p>
<p>Design and implement a wire level regression test suite to exercise various
  states in the TCP/IP protocol suite.  Ideally with both IPv4 and IPv6
  support.</p>
<p><strong>Requirements</strong>:</p>
<ul>
  <li>Strong TCP/IP knowledge.</li>
</ul>
	</desc>
      </idea>

      <idea id="wi">
	<title>Update wi</title>

	<desc>
<p>Many new and useful features (e.g. crypto protocols like WPA) of the WLAN
  infrastructure in the kernel are not used in wi(4).  While wi(4)
  cards are old and can not compete with recent wireless cards, they are still
  in use in a lot of places.  The goal of this item is to examine the WLAN
  infrastructure and other WLAN drivers in the tree for nice features and
  port/use them in the wi(4) driver.</p>
<p><strong>Requirements</strong>:</p>
<ul>
  <li>Knowledge of C.</li>
  <li>No fear of undocumented parts of the kernel.</li>
  <li>One wi(4) card and one other wireless device to test against.</li>
</ul>
	</desc>
      </idea>

      <idea id="wpa2preauth">
	<title>WPA2 preauthentication in hostapd</title>

	<desc>
<p><strong>Technical contact</strong>: <a
  href="mailto:sam@FreeBSD.org">Sam Leffler</a></p>
<p>WPA2 is the authentication protocol defined as part of the IEEE 802.11i
  specification.  This protocol is now commonly used to authenticate
  wireless stations to access points.  Part of this protocol is the
  ability to pre-authenticate a station with one or more access points
  so that roaming can happen quickly.  FreeBSD lacks support for this
  aspect of the protocol in the hostapd program used to construct a
  WPA-enabled access point.  This task would port the Linux code that
  exists to support pre-authentication in hostapd.  This mostly involves
  rewriting some user-mode multicast code and testing the result.</p>
<p><strong>Requirements</strong>:</p>
<ul>
  <li>Good knowledge of C.</li>
  <li>Wireless networking fundamentals.</li>
  <li>WPA-capable wireless network setup.</li>
</ul>
	</desc>
      </idea>


  </category>

  <category>
    <title>Ports</title>
      <idea id="ports-db">
	<title>Add hashed .db support to pkg_tools</title>

	<desc>
<p><strong>Technical contact</strong>: <a
  href="mailto:kris@FreeBSD.org">Kris Kennaway</a></p>
<p>pkg_create(1) and friends use flat databases (aka ordinary
  files and directories in /var/db/pkg) to maintain their data.  This
  makes it cumbersome and/or impossible to do efficient lookups of data
  on installed packages and makes certain operations very slow.
  portupgrade has the right idea of hashing this into a berkeley db
  file, but it uses tools that are not in the base system (ruby).</p>
<p>A self-contained project would be to add similar (preferably
  compatible) code into pkg_tools directly, possibly also extending
  the data that is stored and allowing for more flexible querying with
  tools like pkg_info (e.g. replicating the pkg_which utility of
  portupgrade).  Adding mutual exclusion to protect concurrent
  pkg_add/delete operations from corrupting database state is also
  important.</p>
<p><strong>Requirements</strong>:</p>
<ul>
  <li>Knowledge of C.</li>
  <li>Basic understanding of the use of berkeley db.</li>
</ul>
	</desc>
      </idea>

      <idea id="ports-uid">
	<title>Automatic registering of UID and GID</title>

	<desc>
<p>Some sort of mechanism for adding/removing users/groups automatically,
  rather than using home-brew pkg-install scripts.  It would need to be
  a bit more sophisticated than only registering the UID/GID, to deal with
  setting the other passwd(5) fields; a port might need more than
  one user; some ports might want a specific ID, others just the next
  available one, etc, etc.</p>
<p>Perhaps ports that have UIDs registered in the handbook could also
  be registered in a file inside /usr/ports, which the framework would
  use in UID creation requests.</p>
<p><strong>Requirements</strong>:</p>
<ul>
  <li>Strong knowledge of shell and make code.</li>
  <li>A basic understanding of the inner workings of the ports tree.</li>
</ul>
	</desc>
      </idea>

      <idea id="ports-cleanup-use">
	<title>Cleanup of USE and WITH variables</title>

	<desc>
<p><strong>Technical contact</strong>: <a
  href="mailto:erwin@FreeBSD.org">Erwin Lansing</a></p>
<p>Make these more consistent.  WITH_* should be user-settable
  variables while USE_* only is for internal use in the ports.</p>
<p><strong>Requirement</strong>:</p>
<ul>
  <li>Strong knowledge of shell and make code.</li>
  <li>A basic understanding of the inner workings of the ports tree.</li>
</ul>
	</desc>
      </idea>

      <idea id="ports-collect-messages">
	<title>Collect the pkg-message output</title>

	<desc>
	  <p><strong>Technical contact</strong>: <a
	    href="mailto:pav@FreeBSD.org">Pav Lucistnik</a></p>

	  <p>Collect the pkg-message output of dependencies and print them together
	    after the whole build finishes.</p>

	  <p>Details: Change the current ad-hoc way of including pkg-message in
	    the stdout of the build process.  Automatically display pkg-message
	    in post-install, if present.  For the dependencies, save the copies
	    of pkg-messages, as displayed in post-install, in /var/db/pkg, and
	    display them collectively once the whole build finishes.  Also
	    allow for manual review by user later (new flag to
	    pkg_info(1)).</p>

	  <p><strong>Requirements:</strong></p>

	  <ul>
	    <li>Knowledge of shell and make coding, and basic overview of how
	      ports works.</li>
	    <li>Basic knowledge of C.</li>
	  </ul>

	</desc>
      </idea>

      <idea id="ports-comp43tty">
	<title>COMPAT_43TTY</title>

	<desc>
<p><strong>Technical contact</strong>: <a
  href="mailto:ed@fxq.nl">Ed Schouten</a></p>
<p>Some ports may break when removing COMPAT_43TTY from the kernel
  configuration since they assume old ioctl's when they identify
  FreeBSD.  The goal of this entry is to:</p>
<ul>
  <li>Identify the ports which behave like this.  A tinderbox setup is probably
    needed.  Using grep to find "#include &lt;sgtty.h&gt;" and this <a
    href="http://lists.freebsd.org/pipermail/freebsd-current/2006-June/064010.html">list</a>
    from Kris Kennaway might also be good starting points.</li>
  <li>Fix breakages and send patches upstream.</li>
</ul>
<p><strong>Note</strong>: Ed is working on this. Please coordinate with him.</p>
<p><strong>Requirements</strong>:</p>
<ul>
  <li>Knowledge of autotools.</li>
  <li>Time and patience.</li>
</ul>
	</desc>
      </idea>

      <idea id="ports-options">
	<title>Improvements of OPTIONS</title>

	<desc>
<p>The current OPTIONS infrastructure can be improved in several ways.</p>
<ul>
  <li>It should be possible to define OPTIONS after bsd.ports.pre.mk.</li>
  <li>Add an API to override the current curses based interface with
    a different GUI, e.g. zenity/gdialog instead of dialog.</li>
  <li>More room for a description in the OPTIONS dialog - possibly some
    sort of help dialog could be provided for each option, like in
    sysinstall.</li>
  <li>Better handling of cases where OPTIONS are changed/added/removed
    between upgrades.</li>
  <li>The ability to depend on, or at least test, OPTIONS set in other
    ports.  Possibly it would be nice to enforce setting variables that are
    depended upon when the port is being installed as a dependency.</li>
  <li>Other types of OPTIONS controls - A text box in particular would be
    useful for entering variables that need real values.</li>
  <li>The possibility for mutually exclusive OPTIONS.</li>
  <li>Bugfixes:
    <ul>
      <li>If you attempt to run make config for a port with
	${PKGNAMEPREFIX} defined, the make config process will error out
	with:<br/>
	===> Using wrong configuration file /path/options/file<br/>
	The solution is to define LATEST_LINK to be prefix-${PORTNAME},
	but this should be done internally.</li>
    </ul></li>
</ul>
<p><strong>Requirements</strong>:</p>
<ul>
  <li>Strong knowledge of shell and make code.</li>
  <li>A basic understanding of the inner workings of the ports tree.</li>
</ul>
	</desc>
      </idea>

      <idea id="ports-pkgtools">
	<title>Package tools improvements</title>

	<desc>
<p>The pkg_* tools, which deal with the installation of pre-build binary package
  of ports, could do with a code cleanup or maybe even a rewrite from
  scratch.  Some features of the ports tree are not supported by the pkg_* tools,
  e.g. versioned dependencies.</p>
<p><strong>Requirements</strong>:</p>
<ul>
  <li>Strong knowledge of C code.</li>
  <li>A basic understanding of the inner workings of the ports tree.</li>
</ul>
	</desc>
      </idea>

      <idea class="soc" id="ports-parallel">
	<title>Parallelization in the Ports Collection</title>

	<desc>
	  <p><strong>Technical contact</strong>: <a
	    href="mailto:pav@FreeBSD.org">Pav Lucistnik</a></p>

	  <p>Add locking of write access to PKG_DBDIR (/var/db/pkg), to allow
	    several port builds run in parallel without clobbering the package
	    data.  Should be done both in makefiles and in C tools like
	    pkg_install and pkg_delete.  A simple flock(2) approach over the
	    whole database comes to mind.</p>

	  <p>The next step is the parallelization of dependency building.  Have
	    the port build it's dependencies in parallel, automatically
	    depending on number of CPUs in the machine, or manually specified
	    by user (make -j3 install clean).  Some kind of split screen should
	    be devised, so user can easily watch the process and interact with
	    it (make config screens, for example).  Attention must be paid to
	    prevent deadlocks.</p>

	  <p>Allow for situation when two ports want to build and install
	    common dependency.  One of the ports have to wait on the other to
	    install it before proceeding.</p>

	  <p>And finally, unrelated to previous steps, but also desirable.  Add
	    parallelization inside single builds, ie. enable -jX flag inside
	    vendor makefiles.  This will allow us to exploit the power of
	    multi-core systems when building single port.  Because a lot of
	    vendor code does not work correctly when built with -jX flag, some
	    kind of whitelist or blacklist must be implemented.</p>

	  <p><strong>Requirements</strong>:</p>

	  <ul>
	    <li>Strong knowledge of make and shell code.</li>
	    <li>Strong knowledge of C code.</li>
	    <li>Good understanding of the inner design of the Ports Collection.</li>
	  </ul>
	</desc>
      </idea>

      <idea id="ports-updating">
	<title>UPDATING parser and displayer</title>

	<desc>
	  <p>Write a small C/shell app that will scan the installed ports and
	    show all UPDATING entries that affect one of the installed ports,
	    and are relevant on the given machine (ie. user haven't already performed the update).
	    Possibly the UPDATING format will have to be expanded to record the
	    versions of affected ports, like:</p>

	  <p>gettext&lt;0.16 -> gettext&gt;=0.16</p>

	  <p>The app will be used standalone, and called from pkg_version or
	    portupgrade.</p>

	 <p><strong>Requirements</strong>:</p>
	 <ul>
	   <li>Basic shell/C coding.</li>
	 </ul>
	</desc>
      </idea>

      <idea id="ports-upgrade">
	<title>Utility for safe updating of ports in base system</title>

	<desc>
	  <p>Also known as <em>rewrite portupgrade in C</em>.</p>

	  <p>Write a new utility for the pkg_install suite, possibly named
	    pkg_upgrade(1), implementing a subset of existing portupgrade
	    functionality.  The required functionality is:</p>

	  <ul>
	    <li>fixing @pkgdep records in +CONTENTS file</li>
	    <li>fixing +REQUIRED_BY records</li>
	    <li>storing old copies of shared libraries after shmajor number
	      change in /usr/local/lib/compat/pkg</li>
	    <li>upwards and downwards recursive modes</li>
	  </ul>

	  <p>Anything that existing portupgrade can do is a desired
	    functionality.  It would be nice to be command line compatible with
	    portupgrade, but it's not a requirement.</p>

	  <p><strong>Requirements</strong>:</p>

	  <ul>
	    <li>Basic understanding of the Ports Collection design.</li>
	    <li>Good skills writing C code.</li>
	    <li>Ability to read Ruby will help.</li>
	  </ul>
	</desc>
      </idea>

  </category>

  <category>
    <title>Security</title>
      <idea id="auditkernel" class="soc">
	<title>Audit kernel event sources</title>

	<desc>
<p><strong>Technical contact</strong>: <a
  href="mailto:rwatson@FreeBSD.org">Robert Watson</a></p>
<p>
A number of kernel security subsystems, such as IPFW and pf, generate
security log data.  This task involves identifying potential sources of
security event information in the kernel and modifying kernel subsystems to
log that information using the kernel security event auditing system.
User and programmer documentation of audit may be found on the <a
href="http://www.trustedbsd.org/docs.html">TrustedBSD Documentation Page</a>.
There are also extensive manual pages relating to audit in FreeBSD.  This
project will require careful security analysis and kernel programming, and
will likely need some re-working of the kernel audit framework (which is
currently entirely focused on gathering user and kernel system call audit
data).
</p>
<p><strong>Requirements</strong>:</p>
<ul>
  <li>Strong C programming skills.</li>
  <li>Familiarity with concurrent programming techniques.</li>
  <li>General understanding of TCP/IP firewalls.</li>
  <li>Willingness to read the CC/CAPP specification.</li>
</ul>
	</desc>
      </idea>

      <idea id="distribaudit" class="soc">
	<title>Distributed audit daemon</title>

	<desc>
<p><strong>Technical contact</strong>: <a
  href="mailto:rwatson@FreeBSD.org">Robert Watson</a></p>
<p>Create a tool that manages per-machine audit records and submits them to
  a central site for processing and long-term archiving/management.  Ideally
  with support for SSL (or the like) so they do not travel on the wire in the
  clear.</p>
<p><strong>Requirements</strong>:</p>
<ul>
  <li>Strong (portable) C programming skills.</li>
  <li>Knowledge of the audit subsystem.</li>
</ul>
	</desc>
      </idea>

      <idea id="mac" class="soc">
	<title>Mandatory Access Control</title>
	<desc>
<p><strong>Technical contact</strong>: <a
  href="mailto:rwatson@FreeBSD.org">Robert Watson</a></p>
<p>
FreeBSD 5.0 was the first FreeBSD release to ship with support for Mandatory
Access Control (MAC), an access control technology allowing system
administrators to implement multi-level security, integrity protection, and
other "mandatory" policies.  Policies may be compiled into the kernel, or
loaded as loadable kernel modules.
Later revisions of FreeBSD and the MAC Framework enhanced MAC support,
and additional policy modules were made available, such as a port of the
SELinux FLASK/TE framework available as a third party policy module.
However, many of the sample MAC modules included with FreeBSD are considered
experimental examples of what the technology can be used for, rather than
production policies.
For example, the Biba integrity policy can be deployed in production, but
requires significant tuning to do so effectively.
</p>
<p>
This task involves a general review of the MAC Framework and Policy modules,
with the goal of identifying improvement areas.  It also involves specific
cleanups, optimizations, and completeness work on specific policy modules --
most importantly, the Biba and MLS sample labeled policy modules.  Work there
includes improving memory overhead and efficiency; for example, moving from
allocating complete labels for every labeled object to referencing common
label storage where labels are identical, which occurs a great deal of the
time in most systems.
Other cleanups include moving towards a canonical/extensible on-disk label
storage format, adding regression tests, investigating interactions with user
applications, and writing documentation.
</p>
<p><strong>Requirements</strong>:</p>
<ul>
  <li>Strong C programming skills.</li>
  <li>Familiarity with OS security policies, including discretionary and
    mandatory access control.</li>
  <li>Familiarity with concurrent programming techniques.</li>
  <li>Willingness to read the CC/CAPP specification.</li>
</ul>
	</desc>
      </idea>

      <idea id="securityregression" class="soc">
	<title>Security regression tests</title>

	<desc>
<p><strong>Technical contact</strong>: <a
  href="mailto:rwatson@FreeBSD.org">Robert Watson</a></p>
<p>
FreeBSD is undergoing constant and active improvement to all of its critical
subsystems, from file systems to the network stack.  With any change, there
is a risk of introducing bugs or regressions.  The goal of this task is to
produce a security regression test suite, which encapsulates requirements
regarding system security properties and tests that they (still) hold.  Areas
to test include file system access control, privilege, authentication,
cryptography, process containment, and more.  There are some current tests
along these lines in the <a
href="http://www.freebsd.org/cgi/cvsweb.cgi/src/tools/regression/">FreeBSD
regression test tree</a>, but they are both incomplete and and inadequate.
New tests must be created; existing tests must be completed and updated.
</p>
<p><strong>Requirements</strong>:</p>
<ul>
  <li>Strong C programming skills.</li>
  <li>High tolerance for writing test code.</li>
  <li>High tolerance for reading API specifications.</li>
  <li>Rigorous and devious mindset.</li>
</ul>
	</desc>
      </idea>

  </category>

  <category>
    <title>Userland / Installation Tools</title>

      <idea id="bsdelftools" class="soc">
	<title>BSD-licensed ELF Tools</title>

	<desc>
<p><strong>Technical contact</strong>: <a
  href="mailto:jkoshy@FreeBSD.org">Joseph Koshy</a></p>
<p>Create BSD-licensed versions of ELF processing tools (e.g., <strong>nm</strong>
  and <strong>strip</strong>) using the ELF(3) and GELF(3) API set in FreeBSD
  -CURRENT.</p>
<p><strong>Requirements</strong>:</p>
<ul>
 <li>Knowledge of C.</li>
</ul>
	</desc>
      </idea>

      <idea id="bsdtexttools" class="soc">
	<title>BSD-licensed Text-Processing Tools</title>

	<desc>
<p><strong>Technical contact</strong>: <a
  href="mailto:dds@FreeBSD.org">Diomidis Spinellis</a></p>
<p>Create/port BSD-licensed versions of one or more of the text processing
   tools that are currently missing from the FreeBSD distribution:
   <strong>sort</strong>,
   <strong>diff</strong>, and the
   <strong>grep</strong> family.
   Licensed versions of some or all of these tools are already included
   in OpenBSD, so this task involves more porting and feature completion
   than development from scratch.
   Emphasis should be placed on performance, standards-compliance, and support
   for handling wide character sets.
</p>
<p><strong>Requirements</strong>:</p>
<ul>
 <li>Knowledge of C.</li>
</ul>
	</desc>
      </idea>

      <idea id="noswitches">
	<title>Build options improvements</title>

	<desc>
<p><strong>Technical contact</strong>: <a
  href="mailto:netchild@FreeBSD.org">Alexander Leidinger</a>, <a href="mailto:gbell72@rogers.com">Gardner Bell</a></p>
<p>The new "delete-old" and "delete-old-libs" target in /usr/src for 6.1 and
  -CURRENT should be extended to support the WITHOUT_* knobs, e.g.
  WITHOUT_RESCUE or WITHOUT_CRYPT, and delete files which are covered by those
  knobs.  Some switches have already been <a
  href="http://cvsweb.freebsd.org/src/tools/build/mk/OptionalObsoleteFiles.inc">covered</a>.
  You can view a list of all switches and what effect they have <a
  href="http://phk.freebsd.dk/misc/build_options/">here</a>.</p>
<p><strong>Requirements</strong>:</p>
<ul>
  <li>Time to build and install the world several times.</li>
  <li>A way to determine which files were not touched by an installworld.</li>
</ul>
	</desc>
      </idea>

      <idea id="gnomekde-freebsd-update" class="soc">
	<title>GNOME and/or KDE front-ends to the freebsd-update(8)
	  utility</title>

	<desc>
<p><strong>Technical contact</strong>: <a
  href="mailto:cperciva@FreeBSD.org">Colin Percival</a></p>
<p>The freebsd-update(8) utility is used to fetch, install, and rollback
  binary updates to the FreeBSD base system.  A nice project would be to
  develop at graphical front-end for freebsd-update(8), using the GTK and/or
  QT toolkits.</p>
<p><strong>Requirements</strong>:</p>
<ul>
  <li>Experience writing GNOME and/or KDE applications</li>
</ul>
	</desc>
      </idea>

      <idea id="ipv6-userland" class="soc">
        <title>IPv6 User Land Cleanup</title>

        <desc>
<p><strong>Technical contact</strong>: <a
  href="mailto:gnn@FreeBSD.org">George V. Neville-Neil</a></p>

<p>Many userland network utilities do not work correctly with IPv6.</p>
  <ul>
    <li>rpc.statd(8) is not IPv6 clean.</li>
    <li>rpc.rquotad(8) is not IPv6 clean.</li>
    <li>who(1) truncates IPv6 addresses in its output.</li>
  </ul>

<p>This project could also include a broader survey of other network
services in /usr/bin and /usr/sbin to make sure they're all IPv6
clean.</p>
        </desc>
      </idea>

      <idea id="lint">
	<title>lint(1) improvements from OpenBSD</title>

	<desc>
<p>OpenBSD has some improvements to lint(1) which may be beneficial to
  have.</p>
<p><strong>Requirements</strong>:</p>
<ul>
  <li>Good knowledge of C.</li>
</ul>
	</desc>
      </idea>

      <idea id="libprocnet">
	<title>Libprocstat and libnetstat</title>

	<desc>
<p><strong>Technical contact</strong>: <a
  href="mailto:rwatson@FreeBSD.org">Robert Watson</a></p>
<p>Create, similar to libmemstat, wrapper libraries to support monitoring and
  management applications to avoid direct use of kvm.  Three parts to the
  project: for each of the above, add kernel support to export data in a less
  ABI-sensitive way using sysctl, write a library to present the information
  in an extensible way to applications, and update applications to use the
  library instead of reaching directly into kernel memory / consuming sysctls.
  The goal is to allow the kernel implementation to change without breaking
  applications and requiring them to be recompiled, and to allow monitoring
  functions to be extended without breaking applications.  This should also
  facilitate writing new classes of monitoring and profiling tools.</p>
<p><strong>Requirements</strong>:</p>
<ul>
  <li>Good knowledge of C.</li>
</ul>
	</desc>
      </idea>

      <idea id="multibyte">
	<title>Multibyte collation support</title>

	<desc>
<p>Currently FreeBSD supports only single byte collation.  Multibyte
  collation support would be nice.</p>
<p><strong>Benefits</strong>:</p>
<ul>
  <li>Proper national sorting in UTF-8 and other multibyte locales.</li>
</ul>
<p><strong>Requirements</strong>:</p>
<ul>
  <li>Knowledge of C.</li>
  <li>Familiarity with locale subsystem and relevant ISO standards.</li>
</ul>
	</desc>
      </idea>

      <idea id="ndmp">
	<title>NDMP data server</title>

	<desc>
<p><strong>URL</strong>: <a
  href="http://www.ndmp.org/">The NDMP Initiative</a></p>
<p>The NDMP initiative was launched to create an open
  standard protocol for network-based backup for network-attached storage.
  Major commercial storage systems come with a compliant service. This allows
  major commercial backup systems to backup such NAS devices. Including a NDMP
  disk server into FreeBSD would allow to play nice out of the box (modulo some
  configuring) regarding backups in a corporate environment.</p>
<ul>
  <li>Evaluate the existing revisions of the NDMP standard.</li>
  <li>Choose an appropriate revision (after checking of supported versions in
    commercial backup systems).</li>
  <li>Implement at least a NDMP data server.</li>
  <li>Bonus: implement a NDMP tape server (to allow attached tapes to be
    used).</li>
</ul>
<p><strong>Requirements</strong>:</p>
<ul>
  <li>Access to a commercial backup system with NDMP support
    (mostly for interoperability testing; since a NDMPcopy
    application seems to be available, this is not a hard requirement).</li>
  <li>Good knowledge of a programming language which is included in
    the base system.</li>
  <li>Knowledge about UFS snapshots.</li>
</ul>
	</desc>
      </idea>

      <idea id="performancetracking" class="soc">
	<title>Performance tracking</title>

	<desc>
<p><strong>Technical contact</strong>: <a
  href="mailto:brooks@FreeBSD.org">Brooks Davis</a></p>
<p>The "performance tracking" entry is meant to monitor the
  performance of FreeBSD itself over the development time, e.g. someone
  makes a change to the kernel and the tracking system is able to show
  the performance impact to various subsystems (microbenchmarks) or to
  real world applications like apache or mysql (macrobenchmarks).  The
  tracking system should be able to do this with multiple machines and
  multiple configurations (while the goal is not to compare
  configurations or machines (but different FreeBSD versions) we would
  not mind if it is also able to do this.  This does not need to be
  implemented from scratch, it is allowed/encouraged to reuse existing
  free software.</p>
<p><strong>Requirements</strong>:</p>
<ul>
  <li>Access to multiple machines.</li>
</ul>
	</desc>
      </idea>

      <idea id="libumem">
	<title>Port libumem to FreeBSD</title>

	<desc>
<p>Solaris 9 and later versions include <code>libumem</code>, a user
  space slab allocator that includes debugging features we may want to
  have on FreeBSD too.</p>
<p><a href="mailto:leeym@FreeBSD.org">Yen-Ming Lee</a> has a port of
  the <a href="http://sourceforge.net/projects/umem">Linux port</a>.  He
  is looking for someone who is interested in benchmarking, testing, or
  evaluating his port.</p>
<p><a href="mailto:jasone@FreeBSD.org">Jason Evans</a> has a benchmark
  suite at <a
    href="http://people.freebsd.org/~jasone/jemalloc/benchmarks/benchmarks.tbz">
  here</a>.  A description of the benchmark can be found in his
  <a href="http://people.freebsd.org/~jasone/jemalloc/bsdcan2006/jemalloc.pdf">
  jemalloc paper</a></p>
<p>Online references for <code>libumem</code> are (in suggested reading
  order):</p>
<ul>
  <li>Robert Benson.
    "<em>Identifying Memory Management Bugs Within Applications Using
      the libumem Library</em>".
    Technical article at
      <a href="http://access1.sun.com/">Sun Developer Technical Support</a>.
    <a href="http://access1.sun.com/techarticles/libumem.html">http://access1.sun.com/techarticles/libumem.html</a>.
    2003.</li>

  <li>Jeff Bonwick.
    "<em>The Slab Allocator: An Object-Caching Kernel</em>".
    USENIX Summer 1994 Technical Conference.
    June 6-10, 1994.
    <a href="http://www.usenix.org/publications/library/proceedings/bos94/bonwick.html">http://www.usenix.org/publications/library/proceedings/bos94/bonwick.html</a></li>

  <li>John Adams and Jeff Bonwick.
    "<em>Magazines and Vmem: Extending the Slab Allocator to Many CPUs
      and Arbitrary Resources</em>".
    <a href="http://www.usenix.org/event/usenix01/index.html">USENIX 2001</a>.
    <a href="http://www.usenix.org/event/usenix01/bonwick.html">http://www.usenix.org/event/usenix01/bonwick.html</a></li>
</ul>
<p><strong>Requirements</strong>:</p>
<ul>
  <li>Good C knowledge (reading and writing).</li>
  <li>Experience with debugging allocation problems.</li>
</ul>
	</desc>
      </idea>

      <idea id="prebind">
	<title>Port prebind from OpenBSD</title>

	<desc>
<p>The OpenBSD prebind is a secure implementation of prelinking that
  is compatible with address space randomization.  Prelinking allows to
  speed up application startup when a lot of libraries are involved.
  This should show a noticeable effect with e.g. GNOME/KDE.</p>
<p><strong>Requirements</strong>:</p>
<ul>
  <li>Good C knowledge (reading and writing).</li>
</ul>
	</desc>
      </idea>

      <idea id="pxeinstaller">
	<title>PXE Installer</title>

	<desc>
<p>It would be great to have a bundled PXE installer.  This would allow one to
  boot an install server from a FreeSBIE live CD-ROM on one box, set the BIOS
  on subsequent boxes to PXE boot, and then have the rest happen by magic.
  This would be very helpful for installing cluster nodes, etc.</p>
<p><a href="mailto:m@FreeBSD.org">Markus Boelter</a> is <a
  href="http://wiki.freebsd.org/MarkusBoelter">working</a> on a bundled
  PXE installer as part of his BSDInstaller project within the Google Summer
  of Code 2006. The PXE Installer is working but some non-PXE related issues
  have to be solved before it can enter the tree.</p>
<p><strong>Requirements</strong>:</p>
<ul>
  <li>Good PXE knowledge.</li>
</ul>
	</desc>
      </idea>

      <idea id="regression">
	<title>Regression testing system</title>

	<desc>
<p><strong>Technical contact</strong>: <a
  href="mailto:netchild@FreeBSD.org">Alexander Leidinger</a>, <a
  href="mailto:nik@FreeBSD.org">Nik Clayton</a></p>
<p>Nik has written a regression test infrastructure using Perl.  More of
  the regression tests should be made to work with libtap.</p>
<ul>
  <li>Many of the existing tests should be moved from using assert() to using
    ok() and friends from libtap.</li>
  <li>More regression tests should be written.</li>
</ul>
<p>Porting <a href="http://ltp.sf.net/">LTP</a> might also be a good idea.</p>
<p><strong>Requirements</strong>:</p>
<ul>
  <li>Good knowledge of scripting languages (Perl preferred).</li>
  <li>Good knowledge of software testing.</li>
</ul>
	</desc>
      </idea>


      <idea id="schedgraph" class="soc">
        <title>Schedgraph Improvements</title>

        <desc>
<p><strong>Technical contact</strong>: <a href="mailto:jeff@FreeBSD.org">Jeff Robertson</a></p>

<p>Schedgraph is a tool for analyzing scheduling events and visualy
displaying them in such a way that they reveal interesting kernel
and application performance problems.  It is written in python/tkinter
and interfaces with the kernel via the generic KTR kernel tracing
system. Schedgraph is in need of many features and general
improvements such as the ability to synchronize timestamps in SMP
systems, plotting time spent spinning on spinlocks, improved visual
appearance, faster graphing time, and many other features.  Access to
an 8 processor FreeBSD machine will be provided to implement advanced
SMP features.</p>

<p><strong>Requirements</strong>:</p>
<ul>
  <li>Working understanding of python.</li>
  <li>Some familiarity with any widget set recommended.</li>
  <li>Ability to recompile and reconfigure a FreeBSD kernel.</li>
</ul>
        </desc>
      </idea>

      <idea id="sysinstall">
	<title>Sysinstall</title>

	<desc>
<ul>
  <li>Ask for network configuration before install - so you do not have to
    configure the net twice.</li>
  <li>Make a guess of the timezone based upon country and keyboard.</li>
</ul>
<p><strong>Requirements</strong>:</p>
<ul>
  <li>Good C knowledge (reading and writing).</li>
  <li>No fear regarding "naturally grown" code.</li>
</ul>
	</desc>
      </idea>

      <idea id="taroutmode">
	<title>Tar output mode for installworld</title>

	<desc>
<p><strong>Technical contact</strong>: <a
  href="mailto:rwatson@FreeBSD.org">Robert Watson</a>, <a
  href="mailto:cperciva@FreeBSD.org">Colin Percival</a></p>

<p>Instead of installing using install, mkdir, mtree, etc, directly construct
  a tarball.  This would allow creating install distributions without root
  access, as setuid etc would never hit the local disk.  This would require
  some retrofitting of our installation mechanisms.</p>
<p><strong>Requirements</strong>:</p>
<ul>
  <li>No fear regarding our installation system.</li>
</ul>
	</desc>
      </idea>

      <idea id="vi-utf8">
	<title>Unicode support in vi</title>

	<desc>
<p>Many base system utilities grew multibyte support in 2004.  It would be
  nice to continue this trend by teaching vi(1) to display and edit
  documents in UTF-8 encoding.</p>
<p><strong>Requirements</strong>:</p>
<ul>
  <li>Knowledge of C.</li>
</ul>
	</desc>
      </idea>
  </category>
</ideas>
